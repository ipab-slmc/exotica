#!/usr/bin/env python

# Usage:
#   python example_dynamic_time_indexed [problem_id]
# 
from __future__ import print_function, division

import pyexotica as exo
import exotica_ilqr_solver_py, exotica_ddp_solver_py, exotica_ilqg_solver_py
from pyexotica.publish_trajectory import *
import signal, sys
from time import time, sleep
import numpy as np

exo.Setup.init_ros()
sleep(0.2)

configs = [
    '{exotica_examples}/resources/configs/dynamic_time_indexed/01_ilqr_cartpole.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/02_ilqr_lwr.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/03_ilqr_valkyrie.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/04_analytic_ddp_cartpole.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/05_analytic_ddp_lwr.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/06_analytic_ddp_valkyrie.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/07_control_limited_ddp_cartpole.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/08_control_limited_ddp_lwr.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/09_control_limited_ddp_valkyrie.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/10_ilqg_cartpole.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/11_ilqg_lwr.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/12_ilqg_valkyrie.xml',
    '{exotica_examples}/resources/configs/dynamic_time_indexed/13_control_limited_ddp_quadrotor.xml',
]

problem_idx = int(sys.argv[1]) - 1
print('Running with config {0}'.format(configs[problem_idx]))

solver = exo.Setup.load_solver(configs[problem_idx])
problem = solver.get_problem()
solution = solver.solve()

costs = problem.get_cost_evolution()
import matplotlib.pyplot as plt
plt.figure()
plt.plot(range(len(costs[1])), costs[1])
plt.xlabel('Iteration')
plt.ylabel('Cost')
plt.show()

signal.signal(signal.SIGINT, sig_int_handler)
while True:
    try:
        s = time()
        for t in range(problem.T - 1):
            update_start = time()
            # u = solution[t,:]
            # u = problem.U[:,t]
            # print(u)

            u = solver.get_feedback_control(
                problem.X[:,t], t
            )
            problem.update(u, t)
            problem.get_scene().get_kinematic_tree().publish_frames()
            update_end = time()
            if problem.tau > update_end - update_start:
                sleep(problem.tau - (update_end - update_start))
                # sleep(0.2)
        e = time()
        sleep(1)
        print("Time taken to roll-out:", e-s)
    except KeyboardInterrupt:
        break
